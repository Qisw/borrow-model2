function [dev, outS] = cal_dev(paramS, tgS, cS)
% Deviation from calibration targets
%{
IN
   paramS :: CalParams
      calibrated parameter object
   tgS
      calibration targets
   cS
      constants
%}

rTime = randomLH.rand_time;
n = cS.nEndow;

% Make blank solution object
outS = rfm1_bc1.Solution;


%% Multivariate Normal object

% Marginals do not matter
mS = randomLH.MultiVarNormal(zeros(n, 1), ones(n,1));
% Make lower triangular weight matrix from calibrated params
wtM = paramS.weight_matrix(cS);
% Implied cov matrix
outS.covM = mS.cov_from_weights(wtM, cS.dbg);
% Draw endowments
rng(251);
randM = mS.draw_given_weights(cS.nSim, wtM, cS.dbg);


%% Compute E(a | other vars)

% Condition on everything but a
idxCondV = 1 : n;
idxCondV(cS.idxA) = [];

% Same without IQ
idxCondNoIqV = 1 : n;
idxCondNoIqV([cS.idxA, cS.idxQ]) = [];

outS.eaV = zeros(cS.nSim, 1);
%outS.eaNoV = zeros(cS.nSim, 1);
for i1 = 1 : cS.nSim
   outS.eaV(i1) = mS.conditional_distrib(idxCondV, randM(i1, idxCondV), outS.covM, cS.dbg);
   % Same without IQ
   %outS.eaNoIqV(i1) = mS.conditional_distrib(idxCondNoIqV, randM(i1, idxCondNoIqV), outS.covM, cS.dbg);
end
validateattributes(outS.eaV, {'double'}, {'finite', 'nonnan', 'nonempty', 'real', 'size', [cS.nSim, 1]})


%% How much does conditioning on IQ reduce var(a)?

[~, outS.condVarAbil] = mS.conditional_distrib(idxCondV, randM(i1, idxCondV), outS.covM, cS.dbg);
[~, condVarNoIqV] = mS.conditional_distrib(idxCondNoIqV, randM(i1, idxCondNoIqV), outS.covM, cS.dbg);
outS.condVarAbilNoIq = condVarNoIqV

devVarAbilNoIq = (cS.varAbilNoIqFactor - outS.condVarAbil ./ outS.condVarAbilNoIq) .^ 2;


%% Assign schooling, IQ, yp groups

cumFracSV = cumsum(tgS.schoolS.frac_scM(:, cS.iCohort));
cumFracSV(end) = 1;
outS.sClassV = distrib_lh.class_assign(outS.eaV, [], cumFracSV, cS.dbg);
validateattributes(outS.sClassV, {'double'}, {'finite', 'nonnan', 'nonempty', 'integer', '>=', 1, '<=', cS.nSchool})

outS.yClassV = distrib_lh.class_assign(randM(:, cS.idxY), [], cS.yClUbV, cS.dbg);
validateattributes(outS.yClassV, {'double'}, {'finite', 'nonnan', 'nonempty', 'integer', '>=', 1, '<=', length(cS.yClUbV)})

outS.qClassV = distrib_lh.class_assign(randM(:, cS.idxQ), [], cS.qClUbV, cS.dbg);
validateattributes(outS.qClassV, {'double'}, {'finite', 'nonnan', 'nonempty', 'integer', '>=', 1, '<=', length(cS.qClUbV)})


%% Compute frac s|q and frac s|y

outS.frac_sqM = accumarray([outS.sClassV, outS.qClassV], 1) ./ cS.nSim;
% pmS = statsLH.ProbMatrix2D('pr_xyM', cnt_sqM ./ sum(cnt_sqM(:)));
% frac_s_qM = pmS.prX_yM;
devM = outS.frac_sqM - tgS.schoolS.frac_sqcM(:,:,cS.iCohort);
devSQ = sum(devM(:) .^ 2);

outS.frac_syM = accumarray([outS.sClassV, outS.yClassV], 1) ./ cS.nSim;
% pmS = statsLH.ProbMatrix2D('pr_xyM', outS.frac_syM ./ sum(outS.frac_syM(:)));
% frac_s_yM = pmS.prX_yM;
devM = outS.frac_syM - tgS.schoolS.frac_sycM(:,:,cS.iCohort);
devSY = sum(devM(:) .^ 2);

dev = devSQ + devSY + devVarAbilNoIq;
validateattributes(dev, {'double'}, {'finite', 'nonnan', 'nonempty', 'real', 'scalar'})


%% Show
if rTime < 0.1
   fprintf('\nDeviation %.3g \n', dev);
   fprintf('  Dev sq: %.3g    sy: %.3g    varAbilNoIq: %.3g \n',   devSQ, devSY, devVarAbilNoIq);   
end


end